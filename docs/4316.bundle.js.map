{"version":3,"file":"4316.bundle.js","sources":["webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/base/common/glob.js"],"sourcesContent":["import { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n            //           in which case also matches (Path Sep followed by Path Val)\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n    }\n}\nexport function splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    // Split up into segments for each slash found\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(segment => segment === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            // Treat globstar specially\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (previousSegmentWasGlobStar) {\n                    return;\n                }\n                regEx += starsToRegExp(2, index === segments.length - 1);\n            }\n            // Anything else, not globstar\n            else {\n                // States\n                let inBraces = false;\n                let braceVal = '';\n                let inBrackets = false;\n                let bracketVal = '';\n                for (const char of segment) {\n                    // Support brace expansion\n                    if (char !== '}' && inBraces) {\n                        braceVal += char;\n                        continue;\n                    }\n                    // Support brackets\n                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                        let res;\n                        // range operator\n                        if (char === '-') {\n                            res = char;\n                        }\n                        // negation operator (only valid on first index in bracket)\n                        else if ((char === '^' || char === '!') && !bracketVal) {\n                            res = '^';\n                        }\n                        // glob split matching is not allowed within character ranges\n                        // see http://man7.org/linux/man-pages/man7/glob.7.html\n                        else if (char === GLOB_SPLIT) {\n                            res = '';\n                        }\n                        // anything else gets escaped\n                        else {\n                            res = escapeRegExpCharacters(char);\n                        }\n                        bracketVal += res;\n                        continue;\n                    }\n                    switch (char) {\n                        case '{':\n                            inBraces = true;\n                            continue;\n                        case '[':\n                            inBrackets = true;\n                            continue;\n                        case '}': {\n                            const choices = splitGlobAware(braceVal, ',');\n                            // Converts {foo,bar} => [foo|bar]\n                            const braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n                            regEx += braceRegExp;\n                            inBraces = false;\n                            braceVal = '';\n                            break;\n                        }\n                        case ']': {\n                            regEx += ('[' + bracketVal + ']');\n                            inBrackets = false;\n                            bracketVal = '';\n                            break;\n                        }\n                        case '?':\n                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                            continue;\n                        case '*':\n                            regEx += starsToRegExp(1);\n                            continue;\n                        default:\n                            regEx += escapeRegExpCharacters(char);\n                    }\n                }\n                // Tail: Add the slash we had split on if there is more to\n                // come and the remaining pattern is not a globstar\n                // For example if pattern: some/**/*.js we want the \"/\" after\n                // some to be included in the RegEx to prevent a folder called\n                // \"something\" to match as well.\n                if (index < segments.length - 1 && // more segments to come after this\n                    (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...\n                        index + 2 < segments.length // ...next segment is ** but there is more segments after that\n                    )) {\n                    regEx += PATH_REGEX;\n                }\n            }\n            // update globstar state\n            previousSegmentWasGlobStar = (segment === GLOBSTAR);\n        });\n    }\n    return regEx;\n}\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle relative patterns\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivials\n    let match;\n    if (T1.test(pattern)) {\n        parsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    const wrappedPattern = function (path, basename) {\n        if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n            // skip glob matching if `base` is not a parent of `path`\n            return null;\n        }\n        // Given we have checked `base` being a parent of `path`,\n        // we can now remove the `base` portion of the `path`\n        // and only match on the remaining path components\n        // For that we try to extract the portion of the `path`\n        // that comes after the `base` portion. We have to account\n        // for the fact that `base` might end in a path separator\n        // (https://github.com/microsoft/vscode/issues/162498)\n        return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n    };\n    // Make sure to preserve associated metadata\n    wrappedPattern.allBasenames = parsedPattern.allBasenames;\n    wrappedPattern.allPaths = parsedPattern.allPaths;\n    wrappedPattern.basenames = parsedPattern.basenames;\n    wrappedPattern.patterns = parsedPattern.patterns;\n    return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base, pattern) {\n    return function (path, basename) {\n        return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, pattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? pattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [pattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n        .split(',')\n        .map(pattern => parsePattern(pattern, options))\n        .filter(pattern => pattern !== NULL), pattern);\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (patternsLength === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = sep === posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n    const nativePathEnd = sep + nativePath;\n    const targetPathEnd = posix.sep + targetPath;\n    let parsedPattern;\n    if (matchPathEnds) {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n        };\n    }\n    else {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n        };\n    }\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n        return function (path) {\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nexport function match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n    const rp = obj;\n    if (!rp) {\n        return false;\n    }\n    return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n        .filter(pattern => pattern !== NULL));\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n        if (patternsLength === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            let resultPromises = undefined;\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                const result = parsedPatterns[i](path, basename);\n                if (typeof result === 'string') {\n                    return result; // immediately return as soon as the first expression matches\n                }\n                // If the result is a promise, we have to keep it for\n                // later processing and await the result properly.\n                if (isThenable(result)) {\n                    if (!resultPromises) {\n                        resultPromises = [];\n                    }\n                    resultPromises.push(result);\n                }\n            }\n            // With result promises, we have to loop over each and\n            // await the result before we can return any result.\n            if (resultPromises) {\n                return (async () => {\n                    for (const resultPromise of resultPromises) {\n                        const result = await resultPromise;\n                        if (typeof result === 'string') {\n                            return result;\n                        }\n                    }\n                    return null;\n                })();\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, base, hasSibling) {\n        let name = undefined;\n        let resultPromises = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            // Pattern matches path\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!base) {\n                    base = basename(path);\n                }\n                if (!name) {\n                    name = base.substr(0, base.length - extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, base, name, hasSibling);\n            if (typeof result === 'string') {\n                return result; // immediately return as soon as the first expression matches\n            }\n            // If the result is a promise, we have to keep it for\n            // later processing and await the result properly.\n            if (isThenable(result)) {\n                if (!resultPromises) {\n                    resultPromises = [];\n                }\n                resultPromises.push(result);\n            }\n        }\n        // With result promises, we have to loop over each and\n        // await the result before we can return any result.\n        if (resultPromises) {\n            return (async () => {\n                for (const resultPromise of resultPromises) {\n                    const result = await resultPromise;\n                    if (typeof result === 'string') {\n                        return result;\n                    }\n                }\n                return null;\n            })();\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', () => name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(match => match ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47 /* CharCode.Slash */ || ch === 92 /* CharCode.Backslash */) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n"],"names":["a","RegExp","e","r","Object","i"],"mappings":"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"}