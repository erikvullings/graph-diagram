{"version":3,"file":"4280.bundle.js","sources":["webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/language.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseMultilineTokens.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensProviderStyling.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/registry/common/platform.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/theme/common/theme.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/theme/common/themeService.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n */\nexport class TokenMetadata {\n    static getLanguageId(metadata) {\n        return (metadata & 255 /* MetadataConsts.LANGUAGEID_MASK */) >>> 0 /* MetadataConsts.LANGUAGEID_OFFSET */;\n    }\n    static getTokenType(metadata) {\n        return (metadata & 768 /* MetadataConsts.TOKEN_TYPE_MASK */) >>> 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */;\n    }\n    static containsBalancedBrackets(metadata) {\n        return (metadata & 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */) !== 0;\n    }\n    static getFontStyle(metadata) {\n        return (metadata & 30720 /* MetadataConsts.FONT_STYLE_MASK */) >>> 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n    }\n    static getForeground(metadata) {\n        return (metadata & 16744448 /* MetadataConsts.FOREGROUND_MASK */) >>> 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n    }\n    static getBackground(metadata) {\n        return (metadata & 4278190080 /* MetadataConsts.BACKGROUND_MASK */) >>> 24 /* MetadataConsts.BACKGROUND_OFFSET */;\n    }\n    static getClassNameFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        let className = 'mtk' + foreground;\n        const fontStyle = this.getFontStyle(metadata);\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            className += ' mtki';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            className += ' mtkb';\n        }\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            className += ' mtku';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            className += ' mtks';\n        }\n        return className;\n    }\n    static getInlineStyleFromMetadata(metadata, colorMap) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        let result = `color: ${colorMap[foreground]};`;\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            result += 'font-style: italic;';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            result += 'font-weight: bold;';\n        }\n        let textDecoration = '';\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            textDecoration += ' underline';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            textDecoration += ' line-through';\n        }\n        if (textDecoration) {\n            result += `text-decoration:${textDecoration};`;\n        }\n        return result;\n    }\n    static getPresentationFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),\n            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),\n            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */),\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ILanguageService = createDecorator('languageService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { countEOL } from '../core/eolCounter.js';\n/**\n * Represents sparse tokens over a contiguous range of lines.\n */\nexport class SparseMultilineTokens {\n    static create(startLineNumber, tokens) {\n        return new SparseMultilineTokens(startLineNumber, new SparseMultilineTokensStorage(tokens));\n    }\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._endLineNumber;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    toString() {\n        return this._tokens.toString(this._startLineNumber);\n    }\n    _updateEndLineNumber() {\n        this._endLineNumber = this._startLineNumber + this._tokens.getMaxDeltaLine();\n    }\n    isEmpty() {\n        return this._tokens.isEmpty();\n    }\n    getLineTokens(lineNumber) {\n        if (this._startLineNumber <= lineNumber && lineNumber <= this._endLineNumber) {\n            return this._tokens.getLineTokens(lineNumber - this._startLineNumber);\n        }\n        return null;\n    }\n    getRange() {\n        const deltaRange = this._tokens.getRange();\n        if (!deltaRange) {\n            return deltaRange;\n        }\n        return new Range(this._startLineNumber + deltaRange.startLineNumber, deltaRange.startColumn, this._startLineNumber + deltaRange.endLineNumber, deltaRange.endColumn);\n    }\n    removeTokens(range) {\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        this._startLineNumber += this._tokens.removeTokens(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        this._updateEndLineNumber();\n    }\n    split(range) {\n        // split tokens to two:\n        // a) all the tokens before `range`\n        // b) all the tokens after `range`\n        const startLineIndex = range.startLineNumber - this._startLineNumber;\n        const endLineIndex = range.endLineNumber - this._startLineNumber;\n        const [a, b, bDeltaLine] = this._tokens.split(startLineIndex, range.startColumn - 1, endLineIndex, range.endColumn - 1);\n        return [new SparseMultilineTokens(this._startLineNumber, a), new SparseMultilineTokens(this._startLineNumber + bDeltaLine, b)];\n    }\n    applyEdit(range, text) {\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        this.acceptEdit(range, eolCount, firstLineLength, lastLineLength, text.length > 0 ? text.charCodeAt(0) : 0 /* CharCode.Null */);\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength, lastLineLength, firstCharCode);\n        this._updateEndLineNumber();\n    }\n    _acceptDeleteRange(range) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            // Nothing to delete\n            return;\n        }\n        const firstLineIndex = range.startLineNumber - this._startLineNumber;\n        const lastLineIndex = range.endLineNumber - this._startLineNumber;\n        if (lastLineIndex < 0) {\n            // this deletion occurs entirely before this block, so we only need to adjust line numbers\n            const deletedLinesCount = lastLineIndex - firstLineIndex;\n            this._startLineNumber -= deletedLinesCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (firstLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion occurs entirely after this block, so there is nothing to do\n            return;\n        }\n        if (firstLineIndex < 0 && lastLineIndex >= tokenMaxDeltaLine + 1) {\n            // this deletion completely encompasses this block\n            this._startLineNumber = 0;\n            this._tokens.clear();\n            return;\n        }\n        if (firstLineIndex < 0) {\n            const deletedBefore = -firstLineIndex;\n            this._startLineNumber -= deletedBefore;\n            this._tokens.acceptDeleteRange(range.startColumn - 1, 0, 0, lastLineIndex, range.endColumn - 1);\n        }\n        else {\n            this._tokens.acceptDeleteRange(0, firstLineIndex, range.startColumn - 1, lastLineIndex, range.endColumn - 1);\n        }\n    }\n    _acceptInsertText(position, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - this._startLineNumber;\n        if (lineIndex < 0) {\n            // this insertion occurs before this block, so we only need to adjust line numbers\n            this._startLineNumber += eolCount;\n            return;\n        }\n        const tokenMaxDeltaLine = this._tokens.getMaxDeltaLine();\n        if (lineIndex >= tokenMaxDeltaLine + 1) {\n            // this insertion occurs after this block, so there is nothing to do\n            return;\n        }\n        this._tokens.acceptInsertText(lineIndex, position.column - 1, eolCount, firstLineLength, lastLineLength, firstCharCode);\n    }\n}\nclass SparseMultilineTokensStorage {\n    constructor(tokens) {\n        this._tokens = tokens;\n        this._tokenCount = tokens.length / 4;\n    }\n    toString(startLineNumber) {\n        const pieces = [];\n        for (let i = 0; i < this._tokenCount; i++) {\n            pieces.push(`(${this._getDeltaLine(i) + startLineNumber},${this._getStartCharacter(i)}-${this._getEndCharacter(i)})`);\n        }\n        return `[${pieces.join(',')}]`;\n    }\n    getMaxDeltaLine() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return -1;\n        }\n        return this._getDeltaLine(tokenCount - 1);\n    }\n    getRange() {\n        const tokenCount = this._getTokenCount();\n        if (tokenCount === 0) {\n            return null;\n        }\n        const startChar = this._getStartCharacter(0);\n        const maxDeltaLine = this._getDeltaLine(tokenCount - 1);\n        const endChar = this._getEndCharacter(tokenCount - 1);\n        return new Range(0, startChar + 1, maxDeltaLine, endChar + 1);\n    }\n    _getTokenCount() {\n        return this._tokenCount;\n    }\n    _getDeltaLine(tokenIndex) {\n        return this._tokens[4 * tokenIndex];\n    }\n    _getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    _getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    isEmpty() {\n        return (this._getTokenCount() === 0);\n    }\n    getLineTokens(deltaLine) {\n        let low = 0;\n        let high = this._getTokenCount() - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const midDeltaLine = this._getDeltaLine(mid);\n            if (midDeltaLine < deltaLine) {\n                low = mid + 1;\n            }\n            else if (midDeltaLine > deltaLine) {\n                high = mid - 1;\n            }\n            else {\n                let min = mid;\n                while (min > low && this._getDeltaLine(min - 1) === deltaLine) {\n                    min--;\n                }\n                let max = mid;\n                while (max < high && this._getDeltaLine(max + 1) === deltaLine) {\n                    max++;\n                }\n                return new SparseLineTokens(this._tokens.subarray(4 * min, 4 * max + 4));\n            }\n        }\n        if (this._getDeltaLine(low) === deltaLine) {\n            return new SparseLineTokens(this._tokens.subarray(4 * low, 4 * low + 4));\n        }\n        return null;\n    }\n    clear() {\n        this._tokenCount = 0;\n    }\n    removeTokens(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        let firstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))\n                && (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                hasDeletedTokens = true;\n            }\n            else {\n                if (newTokenCount === 0) {\n                    firstDeltaLine = tokenDeltaLine;\n                }\n                if (hasDeletedTokens) {\n                    // must move the token to the left\n                    const destOffset = 4 * newTokenCount;\n                    tokens[destOffset] = tokenDeltaLine - firstDeltaLine;\n                    tokens[destOffset + 1] = tokenStartCharacter;\n                    tokens[destOffset + 2] = tokenEndCharacter;\n                    tokens[destOffset + 3] = tokenMetadata;\n                }\n                newTokenCount++;\n            }\n        }\n        this._tokenCount = newTokenCount;\n        return firstDeltaLine;\n    }\n    split(startDeltaLine, startChar, endDeltaLine, endChar) {\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const aTokens = [];\n        const bTokens = [];\n        let destTokens = aTokens;\n        let destOffset = 0;\n        let destFirstDeltaLine = 0;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            const tokenDeltaLine = tokens[srcOffset];\n            const tokenStartCharacter = tokens[srcOffset + 1];\n            const tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if ((tokenDeltaLine > startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter >= startChar))) {\n                if ((tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter <= endChar))) {\n                    // this token is touching the range\n                    continue;\n                }\n                else {\n                    // this token is after the range\n                    if (destTokens !== bTokens) {\n                        // this token is the first token after the range\n                        destTokens = bTokens;\n                        destOffset = 0;\n                        destFirstDeltaLine = tokenDeltaLine;\n                    }\n                }\n            }\n            destTokens[destOffset++] = tokenDeltaLine - destFirstDeltaLine;\n            destTokens[destOffset++] = tokenStartCharacter;\n            destTokens[destOffset++] = tokenEndCharacter;\n            destTokens[destOffset++] = tokenMetadata;\n        }\n        return [new SparseMultilineTokensStorage(new Uint32Array(aTokens)), new SparseMultilineTokensStorage(new Uint32Array(bTokens)), destFirstDeltaLine];\n    }\n    acceptDeleteRange(horizontalShiftForFirstLineTokens, startDeltaLine, startCharacter, endDeltaLine, endCharacter) {\n        // This is a bit complex, here are the cases I used to think about this:\n        //\n        // 1. The token starts before the deletion range\n        // 1a. The token is completely before the deletion range\n        //               -----------\n        //                          xxxxxxxxxxx\n        // 1b. The token starts before, the deletion range ends after the token\n        //               -----------\n        //                      xxxxxxxxxxx\n        // 1c. The token starts before, the deletion range ends precisely with the token\n        //               ---------------\n        //                      xxxxxxxx\n        // 1d. The token starts before, the deletion range is inside the token\n        //               ---------------\n        //                    xxxxx\n        //\n        // 2. The token starts at the same position with the deletion range\n        // 2a. The token starts at the same position, and ends inside the deletion range\n        //               -------\n        //               xxxxxxxxxxx\n        // 2b. The token starts at the same position, and ends at the same position as the deletion range\n        //               ----------\n        //               xxxxxxxxxx\n        // 2c. The token starts at the same position, and ends after the deletion range\n        //               -------------\n        //               xxxxxxx\n        //\n        // 3. The token starts inside the deletion range\n        // 3a. The token is inside the deletion range\n        //                -------\n        //             xxxxxxxxxxxxx\n        // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n        //                ----------\n        //             xxxxxxxxxxxxx\n        // 3c. The token starts inside the deletion range, and ends after the deletion range\n        //                ------------\n        //             xxxxxxxxxxx\n        //\n        // 4. The token starts after the deletion range\n        //                  -----------\n        //          xxxxxxxx\n        //\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        const deletedLineCount = (endDeltaLine - startDeltaLine);\n        let newTokenCount = 0;\n        let hasDeletedTokens = false;\n        for (let i = 0; i < tokenCount; i++) {\n            const srcOffset = 4 * i;\n            let tokenDeltaLine = tokens[srcOffset];\n            let tokenStartCharacter = tokens[srcOffset + 1];\n            let tokenEndCharacter = tokens[srcOffset + 2];\n            const tokenMetadata = tokens[srcOffset + 3];\n            if (tokenDeltaLine < startDeltaLine || (tokenDeltaLine === startDeltaLine && tokenEndCharacter <= startCharacter)) {\n                // 1a. The token is completely before the deletion range\n                // => nothing to do\n                newTokenCount++;\n                continue;\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter < startCharacter) {\n                // 1b, 1c, 1d\n                // => the token survives, but it needs to shrink\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 1d. The token starts before, the deletion range is inside the token\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 1b. The token starts before, the deletion range ends after the token\n                    // 1c. The token starts before, the deletion range ends precisely with the token\n                    // => the token shrinks its ending to the deletion start\n                    tokenEndCharacter = startCharacter;\n                }\n            }\n            else if (tokenDeltaLine === startDeltaLine && tokenStartCharacter === startCharacter) {\n                // 2a, 2b, 2c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 2c. The token starts at the same position, and ends after the deletion range\n                    // => the token shrinks by the deletion character count\n                    tokenEndCharacter -= (endCharacter - startCharacter);\n                }\n                else {\n                    // 2a. The token starts at the same position, and ends inside the deletion range\n                    // 2b. The token starts at the same position, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine < endDeltaLine || (tokenDeltaLine === endDeltaLine && tokenStartCharacter < endCharacter)) {\n                // 3a, 3b, 3c\n                if (tokenDeltaLine === endDeltaLine && tokenEndCharacter > endCharacter) {\n                    // 3c. The token starts inside the deletion range, and ends after the deletion range\n                    // => the token moves to continue right after the deletion\n                    tokenDeltaLine = startDeltaLine;\n                    tokenStartCharacter = startCharacter;\n                    tokenEndCharacter = tokenStartCharacter + (tokenEndCharacter - endCharacter);\n                }\n                else {\n                    // 3a. The token is inside the deletion range\n                    // 3b. The token starts inside the deletion range, and ends at the same position as the deletion range\n                    // => the token is deleted\n                    hasDeletedTokens = true;\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine > endDeltaLine) {\n                // 4. (partial) The token starts after the deletion range, on a line below...\n                if (deletedLineCount === 0 && !hasDeletedTokens) {\n                    // early stop, there is no need to walk all the tokens and do nothing...\n                    newTokenCount = tokenCount;\n                    break;\n                }\n                tokenDeltaLine -= deletedLineCount;\n            }\n            else if (tokenDeltaLine === endDeltaLine && tokenStartCharacter >= endCharacter) {\n                // 4. (continued) The token starts after the deletion range, on the last line where a deletion occurs\n                if (horizontalShiftForFirstLineTokens && tokenDeltaLine === 0) {\n                    tokenStartCharacter += horizontalShiftForFirstLineTokens;\n                    tokenEndCharacter += horizontalShiftForFirstLineTokens;\n                }\n                tokenDeltaLine -= deletedLineCount;\n                tokenStartCharacter -= (endCharacter - startCharacter);\n                tokenEndCharacter -= (endCharacter - startCharacter);\n            }\n            else {\n                throw new Error(`Not possible!`);\n            }\n            const destOffset = 4 * newTokenCount;\n            tokens[destOffset] = tokenDeltaLine;\n            tokens[destOffset + 1] = tokenStartCharacter;\n            tokens[destOffset + 2] = tokenEndCharacter;\n            tokens[destOffset + 3] = tokenMetadata;\n            newTokenCount++;\n        }\n        this._tokenCount = newTokenCount;\n    }\n    acceptInsertText(deltaLine, character, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        // Here are the cases I used to think about this:\n        //\n        // 1. The token is completely before the insertion point\n        //            -----------   |\n        // 2. The token ends precisely at the insertion point\n        //            -----------|\n        // 3. The token contains the insertion point\n        //            -----|------\n        // 4. The token starts precisely at the insertion point\n        //            |-----------\n        // 5. The token is completely after the insertion point\n        //            |   -----------\n        //\n        const isInsertingPreciselyOneWordCharacter = (eolCount === 0\n            && firstLineLength === 1\n            && ((firstCharCode >= 48 /* CharCode.Digit0 */ && firstCharCode <= 57 /* CharCode.Digit9 */)\n                || (firstCharCode >= 65 /* CharCode.A */ && firstCharCode <= 90 /* CharCode.Z */)\n                || (firstCharCode >= 97 /* CharCode.a */ && firstCharCode <= 122 /* CharCode.z */)));\n        const tokens = this._tokens;\n        const tokenCount = this._tokenCount;\n        for (let i = 0; i < tokenCount; i++) {\n            const offset = 4 * i;\n            let tokenDeltaLine = tokens[offset];\n            let tokenStartCharacter = tokens[offset + 1];\n            let tokenEndCharacter = tokens[offset + 2];\n            if (tokenDeltaLine < deltaLine || (tokenDeltaLine === deltaLine && tokenEndCharacter < character)) {\n                // 1. The token is completely before the insertion point\n                // => nothing to do\n                continue;\n            }\n            else if (tokenDeltaLine === deltaLine && tokenEndCharacter === character) {\n                // 2. The token ends precisely at the insertion point\n                // => expand the end character only if inserting precisely one character that is a word character\n                if (isInsertingPreciselyOneWordCharacter) {\n                    tokenEndCharacter += 1;\n                }\n                else {\n                    continue;\n                }\n            }\n            else if (tokenDeltaLine === deltaLine && tokenStartCharacter < character && character < tokenEndCharacter) {\n                // 3. The token contains the insertion point\n                if (eolCount === 0) {\n                    // => just expand the end character\n                    tokenEndCharacter += firstLineLength;\n                }\n                else {\n                    // => cut off the token\n                    tokenEndCharacter = character;\n                }\n            }\n            else {\n                // 4. or 5.\n                if (tokenDeltaLine === deltaLine && tokenStartCharacter === character) {\n                    // 4. The token starts precisely at the insertion point\n                    // => grow the token (by keeping its start constant) only if inserting precisely one character that is a word character\n                    // => otherwise behave as in case 5.\n                    if (isInsertingPreciselyOneWordCharacter) {\n                        continue;\n                    }\n                }\n                // => the token must move and keep its size constant\n                if (tokenDeltaLine === deltaLine) {\n                    tokenDeltaLine += eolCount;\n                    // this token is on the line where the insertion is taking place\n                    if (eolCount === 0) {\n                        tokenStartCharacter += firstLineLength;\n                        tokenEndCharacter += firstLineLength;\n                    }\n                    else {\n                        const tokenLength = tokenEndCharacter - tokenStartCharacter;\n                        tokenStartCharacter = lastLineLength + (tokenStartCharacter - character);\n                        tokenEndCharacter = tokenStartCharacter + tokenLength;\n                    }\n                }\n                else {\n                    tokenDeltaLine += eolCount;\n                }\n            }\n            tokens[offset] = tokenDeltaLine;\n            tokens[offset + 1] = tokenStartCharacter;\n            tokens[offset + 2] = tokenEndCharacter;\n        }\n    }\n}\nexport class SparseLineTokens {\n    constructor(tokens) {\n        this._tokens = tokens;\n    }\n    getCount() {\n        return this._tokens.length / 4;\n    }\n    getStartCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 1];\n    }\n    getEndCharacter(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 2];\n    }\n    getMetadata(tokenIndex) {\n        return this._tokens[4 * tokenIndex + 3];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nimport { IThemeService } from '../../../platform/theme/common/themeService.js';\nimport { ILogService, LogLevel } from '../../../platform/log/common/log.js';\nimport { SparseMultilineTokens } from '../tokens/sparseMultilineTokens.js';\nimport { ILanguageService } from '../languages/language.js';\nconst ENABLE_TRACE = false;\nlet SemanticTokensProviderStyling = class SemanticTokensProviderStyling {\n    constructor(_legend, _themeService, _languageService, _logService) {\n        this._legend = _legend;\n        this._themeService = _themeService;\n        this._languageService = _languageService;\n        this._logService = _logService;\n        this._hasWarnedOverlappingTokens = false;\n        this._hasWarnedInvalidLengthTokens = false;\n        this._hasWarnedInvalidEditStart = false;\n        this._hashTable = new HashTable();\n    }\n    getMetadata(tokenTypeIndex, tokenModifierSet, languageId) {\n        const encodedLanguageId = this._languageService.languageIdCodec.encodeLanguageId(languageId);\n        const entry = this._hashTable.get(tokenTypeIndex, tokenModifierSet, encodedLanguageId);\n        let metadata;\n        if (entry) {\n            metadata = entry.metadata;\n            if (ENABLE_TRACE && this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling [CACHED] ${tokenTypeIndex} / ${tokenModifierSet}: foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        else {\n            let tokenType = this._legend.tokenTypes[tokenTypeIndex];\n            const tokenModifiers = [];\n            if (tokenType) {\n                let modifierSet = tokenModifierSet;\n                for (let modifierIndex = 0; modifierSet > 0 && modifierIndex < this._legend.tokenModifiers.length; modifierIndex++) {\n                    if (modifierSet & 1) {\n                        tokenModifiers.push(this._legend.tokenModifiers[modifierIndex]);\n                    }\n                    modifierSet = modifierSet >> 1;\n                }\n                if (ENABLE_TRACE && modifierSet > 0 && this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token modifier index: ${tokenModifierSet.toString(2)} for legend: ${JSON.stringify(this._legend.tokenModifiers)}`);\n                    tokenModifiers.push('not-in-legend');\n                }\n                const tokenStyle = this._themeService.getColorTheme().getTokenStyleMetadata(tokenType, tokenModifiers, languageId);\n                if (typeof tokenStyle === 'undefined') {\n                    metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                }\n                else {\n                    metadata = 0;\n                    if (typeof tokenStyle.italic !== 'undefined') {\n                        const italicBit = (tokenStyle.italic ? 1 /* FontStyle.Italic */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= italicBit | 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */;\n                    }\n                    if (typeof tokenStyle.bold !== 'undefined') {\n                        const boldBit = (tokenStyle.bold ? 2 /* FontStyle.Bold */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= boldBit | 2 /* MetadataConsts.SEMANTIC_USE_BOLD */;\n                    }\n                    if (typeof tokenStyle.underline !== 'undefined') {\n                        const underlineBit = (tokenStyle.underline ? 4 /* FontStyle.Underline */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= underlineBit | 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */;\n                    }\n                    if (typeof tokenStyle.strikethrough !== 'undefined') {\n                        const strikethroughBit = (tokenStyle.strikethrough ? 8 /* FontStyle.Strikethrough */ : 0) << 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n                        metadata |= strikethroughBit | 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */;\n                    }\n                    if (tokenStyle.foreground) {\n                        const foregroundBits = (tokenStyle.foreground) << 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n                        metadata |= foregroundBits | 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */;\n                    }\n                    if (metadata === 0) {\n                        // Nothing!\n                        metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                    }\n                }\n            }\n            else {\n                if (ENABLE_TRACE && this._logService.getLevel() === LogLevel.Trace) {\n                    this._logService.trace(`SemanticTokensProviderStyling: unknown token type index: ${tokenTypeIndex} for legend: ${JSON.stringify(this._legend.tokenTypes)}`);\n                }\n                metadata = 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */;\n                tokenType = 'not-in-legend';\n            }\n            this._hashTable.add(tokenTypeIndex, tokenModifierSet, encodedLanguageId, metadata);\n            if (ENABLE_TRACE && this._logService.getLevel() === LogLevel.Trace) {\n                this._logService.trace(`SemanticTokensProviderStyling ${tokenTypeIndex} (${tokenType}) / ${tokenModifierSet} (${tokenModifiers.join(' ')}): foreground ${TokenMetadata.getForeground(metadata)}, fontStyle ${TokenMetadata.getFontStyle(metadata).toString(2)}`);\n            }\n        }\n        return metadata;\n    }\n    warnOverlappingSemanticTokens(lineNumber, startColumn) {\n        if (!this._hasWarnedOverlappingTokens) {\n            this._hasWarnedOverlappingTokens = true;\n            this._logService.warn(`Overlapping semantic tokens detected at lineNumber ${lineNumber}, column ${startColumn}`);\n        }\n    }\n    warnInvalidLengthSemanticTokens(lineNumber, startColumn) {\n        if (!this._hasWarnedInvalidLengthTokens) {\n            this._hasWarnedInvalidLengthTokens = true;\n            this._logService.warn(`Semantic token with invalid length detected at lineNumber ${lineNumber}, column ${startColumn}`);\n        }\n    }\n    warnInvalidEditStart(previousResultId, resultId, editIndex, editStart, maxExpectedStart) {\n        if (!this._hasWarnedInvalidEditStart) {\n            this._hasWarnedInvalidEditStart = true;\n            this._logService.warn(`Invalid semantic tokens edit detected (previousResultId: ${previousResultId}, resultId: ${resultId}) at edit #${editIndex}: The provided start offset ${editStart} is outside the previous data (length ${maxExpectedStart}).`);\n        }\n    }\n};\nSemanticTokensProviderStyling = __decorate([\n    __param(1, IThemeService),\n    __param(2, ILanguageService),\n    __param(3, ILogService)\n], SemanticTokensProviderStyling);\nexport { SemanticTokensProviderStyling };\nexport function toMultilineTokens2(tokens, styling, languageId) {\n    const srcData = tokens.data;\n    const tokenCount = (tokens.data.length / 5) | 0;\n    const tokensPerArea = Math.max(Math.ceil(tokenCount / 1024 /* SemanticColoringConstants.DesiredMaxAreas */), 400 /* SemanticColoringConstants.DesiredTokensPerArea */);\n    const result = [];\n    let tokenIndex = 0;\n    let lastLineNumber = 1;\n    let lastStartCharacter = 0;\n    while (tokenIndex < tokenCount) {\n        const tokenStartIndex = tokenIndex;\n        let tokenEndIndex = Math.min(tokenStartIndex + tokensPerArea, tokenCount);\n        // Keep tokens on the same line in the same area...\n        if (tokenEndIndex < tokenCount) {\n            let smallTokenEndIndex = tokenEndIndex;\n            while (smallTokenEndIndex - 1 > tokenStartIndex && srcData[5 * smallTokenEndIndex] === 0) {\n                smallTokenEndIndex--;\n            }\n            if (smallTokenEndIndex - 1 === tokenStartIndex) {\n                // there are so many tokens on this line that our area would be empty, we must now go right\n                let bigTokenEndIndex = tokenEndIndex;\n                while (bigTokenEndIndex + 1 < tokenCount && srcData[5 * bigTokenEndIndex] === 0) {\n                    bigTokenEndIndex++;\n                }\n                tokenEndIndex = bigTokenEndIndex;\n            }\n            else {\n                tokenEndIndex = smallTokenEndIndex;\n            }\n        }\n        let destData = new Uint32Array((tokenEndIndex - tokenStartIndex) * 4);\n        let destOffset = 0;\n        let areaLine = 0;\n        let prevLineNumber = 0;\n        let prevEndCharacter = 0;\n        while (tokenIndex < tokenEndIndex) {\n            const srcOffset = 5 * tokenIndex;\n            const deltaLine = srcData[srcOffset];\n            const deltaCharacter = srcData[srcOffset + 1];\n            // Casting both `lineNumber`, `startCharacter` and `endCharacter` here to uint32 using `|0`\n            // to validate below with the actual values that will be inserted in the Uint32Array result\n            const lineNumber = (lastLineNumber + deltaLine) | 0;\n            const startCharacter = (deltaLine === 0 ? (lastStartCharacter + deltaCharacter) | 0 : deltaCharacter);\n            const length = srcData[srcOffset + 2];\n            const endCharacter = (startCharacter + length) | 0;\n            const tokenTypeIndex = srcData[srcOffset + 3];\n            const tokenModifierSet = srcData[srcOffset + 4];\n            if (endCharacter <= startCharacter) {\n                // this token is invalid (most likely a negative length casted to uint32)\n                styling.warnInvalidLengthSemanticTokens(lineNumber, startCharacter + 1);\n            }\n            else if (prevLineNumber === lineNumber && prevEndCharacter > startCharacter) {\n                // this token overlaps with the previous token\n                styling.warnOverlappingSemanticTokens(lineNumber, startCharacter + 1);\n            }\n            else {\n                const metadata = styling.getMetadata(tokenTypeIndex, tokenModifierSet, languageId);\n                if (metadata !== 2147483647 /* SemanticTokensProviderStylingConstants.NO_STYLING */) {\n                    if (areaLine === 0) {\n                        areaLine = lineNumber;\n                    }\n                    destData[destOffset] = lineNumber - areaLine;\n                    destData[destOffset + 1] = startCharacter;\n                    destData[destOffset + 2] = endCharacter;\n                    destData[destOffset + 3] = metadata;\n                    destOffset += 4;\n                    prevLineNumber = lineNumber;\n                    prevEndCharacter = endCharacter;\n                }\n            }\n            lastLineNumber = lineNumber;\n            lastStartCharacter = startCharacter;\n            tokenIndex++;\n        }\n        if (destOffset !== destData.length) {\n            destData = destData.subarray(0, destOffset);\n        }\n        const tokens = SparseMultilineTokens.create(areaLine, destData);\n        result.push(tokens);\n    }\n    return result;\n}\nclass HashTableEntry {\n    constructor(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this.tokenTypeIndex = tokenTypeIndex;\n        this.tokenModifierSet = tokenModifierSet;\n        this.languageId = languageId;\n        this.metadata = metadata;\n        this.next = null;\n    }\n}\nclass HashTable {\n    static { this._SIZES = [3, 7, 13, 31, 61, 127, 251, 509, 1021, 2039, 4093, 8191, 16381, 32749, 65521, 131071, 262139, 524287, 1048573, 2097143]; }\n    constructor() {\n        this._elementsCount = 0;\n        this._currentLengthIndex = 0;\n        this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n        this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n        this._elements = [];\n        HashTable._nullOutEntries(this._elements, this._currentLength);\n    }\n    static _nullOutEntries(entries, length) {\n        for (let i = 0; i < length; i++) {\n            entries[i] = null;\n        }\n    }\n    _hash2(n1, n2) {\n        return (((n1 << 5) - n1) + n2) | 0; // n1 * 31 + n2, keep as int32\n    }\n    _hashFunc(tokenTypeIndex, tokenModifierSet, languageId) {\n        return this._hash2(this._hash2(tokenTypeIndex, tokenModifierSet), languageId) % this._currentLength;\n    }\n    get(tokenTypeIndex, tokenModifierSet, languageId) {\n        const hash = this._hashFunc(tokenTypeIndex, tokenModifierSet, languageId);\n        let p = this._elements[hash];\n        while (p) {\n            if (p.tokenTypeIndex === tokenTypeIndex && p.tokenModifierSet === tokenModifierSet && p.languageId === languageId) {\n                return p;\n            }\n            p = p.next;\n        }\n        return null;\n    }\n    add(tokenTypeIndex, tokenModifierSet, languageId, metadata) {\n        this._elementsCount++;\n        if (this._growCount !== 0 && this._elementsCount >= this._growCount) {\n            // expand!\n            const oldElements = this._elements;\n            this._currentLengthIndex++;\n            this._currentLength = HashTable._SIZES[this._currentLengthIndex];\n            this._growCount = Math.round(this._currentLengthIndex + 1 < HashTable._SIZES.length ? 2 / 3 * this._currentLength : 0);\n            this._elements = [];\n            HashTable._nullOutEntries(this._elements, this._currentLength);\n            for (const first of oldElements) {\n                let p = first;\n                while (p) {\n                    const oldNext = p.next;\n                    p.next = null;\n                    this._add(p);\n                    p = oldNext;\n                }\n            }\n        }\n        this._add(new HashTableEntry(tokenTypeIndex, tokenModifierSet, languageId, metadata));\n    }\n    _add(element) {\n        const hash = this._hashFunc(element.tokenTypeIndex, element.tokenModifierSet, element.languageId);\n        element.next = this._elements[hash];\n        this._elements[hash] = element;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as Assert from '../../../base/common/assert.js';\nimport * as Types from '../../../base/common/types.js';\nclass RegistryImpl {\n    constructor() {\n        this.data = new Map();\n    }\n    add(id, data) {\n        Assert.ok(Types.isString(id));\n        Assert.ok(Types.isObject(data));\n        Assert.ok(!this.data.has(id), 'There is already an extension with this id');\n        this.data.set(id, data);\n    }\n    as(id) {\n        return this.data.get(id) || null;\n    }\n}\nexport const Registry = new RegistryImpl();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Color scheme used by the OS and by color themes.\n */\nexport var ColorScheme;\n(function (ColorScheme) {\n    ColorScheme[\"DARK\"] = \"dark\";\n    ColorScheme[\"LIGHT\"] = \"light\";\n    ColorScheme[\"HIGH_CONTRAST_DARK\"] = \"hcDark\";\n    ColorScheme[\"HIGH_CONTRAST_LIGHT\"] = \"hcLight\";\n})(ColorScheme || (ColorScheme = {}));\nexport function isHighContrast(scheme) {\n    return scheme === ColorScheme.HIGH_CONTRAST_DARK || scheme === ColorScheme.HIGH_CONTRAST_LIGHT;\n}\nexport function isDark(scheme) {\n    return scheme === ColorScheme.DARK || scheme === ColorScheme.HIGH_CONTRAST_DARK;\n}\n","import { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nimport * as platform from '../../registry/common/platform.js';\nimport { ColorScheme } from './theme.js';\nexport const IThemeService = createDecorator('themeService');\nexport function themeColorFromId(id) {\n    return { id };\n}\nexport function getThemeTypeSelector(type) {\n    switch (type) {\n        case ColorScheme.DARK: return 'vs-dark';\n        case ColorScheme.HIGH_CONTRAST_DARK: return 'hc-black';\n        case ColorScheme.HIGH_CONTRAST_LIGHT: return 'hc-light';\n        default: return 'vs';\n    }\n}\n// static theming participant\nexport const Extensions = {\n    ThemingContribution: 'base.contributions.theming'\n};\nclass ThemingRegistry {\n    constructor() {\n        this.themingParticipants = [];\n        this.themingParticipants = [];\n        this.onThemingParticipantAddedEmitter = new Emitter();\n    }\n    onColorThemeChange(participant) {\n        this.themingParticipants.push(participant);\n        this.onThemingParticipantAddedEmitter.fire(participant);\n        return toDisposable(() => {\n            const idx = this.themingParticipants.indexOf(participant);\n            this.themingParticipants.splice(idx, 1);\n        });\n    }\n    getThemingParticipants() {\n        return this.themingParticipants;\n    }\n}\nconst themingRegistry = new ThemingRegistry();\nplatform.Registry.add(Extensions.ThemingContribution, themingRegistry);\nexport function registerThemingParticipant(participant) {\n    return themingRegistry.onColorThemeChange(participant);\n}\n/**\n * Utility base class for all themable components.\n */\nexport class Themable extends Disposable {\n    constructor(themeService) {\n        super();\n        this.themeService = themeService;\n        this.theme = themeService.getColorTheme();\n        // Hook up to theme changes\n        this._register(this.themeService.onDidColorThemeChange(theme => this.onThemeChange(theme)));\n    }\n    onThemeChange(theme) {\n        this.theme = theme;\n        this.updateStyles();\n    }\n    updateStyles() {\n        // Subclasses to override\n    }\n}\n"],"names":["t","e","r","Math","h","s","a","Uint32Array","Error","o","l","d","arguments","Object","Reflect","Map"],"mappings":"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"}