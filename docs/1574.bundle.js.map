{"version":3,"file":"1574.bundle.js","sources":["webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/base/common/buffer.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/eolCounter.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/encodedTokenAttributes.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/language.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/treeSitterTokens.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/model/utils.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js","webpack://graph-diagram/./node_modules/.pnpm/monaco-editor@0.52.2/node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Lazy } from './lazy.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\nlet textDecoder;\nexport class VSBuffer {\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24\n        + source[offset + 1] * 2 ** 16\n        + source[offset + 2] * 2 ** 8\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function countEOL(text) {\n    let eolCount = 0;\n    let firstLineLength = 0;\n    let lastLineStart = 0;\n    let eol = 0 /* StringEOL.Unknown */;\n    for (let i = 0, len = text.length; i < len; i++) {\n        const chr = text.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            if (i + 1 < len && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                eol |= 2 /* StringEOL.CRLF */;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                eol |= 3 /* StringEOL.Invalid */;\n            }\n            lastLineStart = i + 1;\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            // \\n... case\n            eol |= 1 /* StringEOL.LF */;\n            if (eolCount === 0) {\n                firstLineLength = i;\n            }\n            eolCount++;\n            lastLineStart = i + 1;\n        }\n    }\n    if (eolCount === 0) {\n        firstLineLength = text.length;\n    }\n    return [eolCount, firstLineLength, text.length - lastLineStart, eol];\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n */\nexport class TokenMetadata {\n    static getLanguageId(metadata) {\n        return (metadata & 255 /* MetadataConsts.LANGUAGEID_MASK */) >>> 0 /* MetadataConsts.LANGUAGEID_OFFSET */;\n    }\n    static getTokenType(metadata) {\n        return (metadata & 768 /* MetadataConsts.TOKEN_TYPE_MASK */) >>> 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */;\n    }\n    static containsBalancedBrackets(metadata) {\n        return (metadata & 1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */) !== 0;\n    }\n    static getFontStyle(metadata) {\n        return (metadata & 30720 /* MetadataConsts.FONT_STYLE_MASK */) >>> 11 /* MetadataConsts.FONT_STYLE_OFFSET */;\n    }\n    static getForeground(metadata) {\n        return (metadata & 16744448 /* MetadataConsts.FOREGROUND_MASK */) >>> 15 /* MetadataConsts.FOREGROUND_OFFSET */;\n    }\n    static getBackground(metadata) {\n        return (metadata & 4278190080 /* MetadataConsts.BACKGROUND_MASK */) >>> 24 /* MetadataConsts.BACKGROUND_OFFSET */;\n    }\n    static getClassNameFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        let className = 'mtk' + foreground;\n        const fontStyle = this.getFontStyle(metadata);\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            className += ' mtki';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            className += ' mtkb';\n        }\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            className += ' mtku';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            className += ' mtks';\n        }\n        return className;\n    }\n    static getInlineStyleFromMetadata(metadata, colorMap) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        let result = `color: ${colorMap[foreground]};`;\n        if (fontStyle & 1 /* FontStyle.Italic */) {\n            result += 'font-style: italic;';\n        }\n        if (fontStyle & 2 /* FontStyle.Bold */) {\n            result += 'font-weight: bold;';\n        }\n        let textDecoration = '';\n        if (fontStyle & 4 /* FontStyle.Underline */) {\n            textDecoration += ' underline';\n        }\n        if (fontStyle & 8 /* FontStyle.Strikethrough */) {\n            textDecoration += ' line-through';\n        }\n        if (textDecoration) {\n            result += `text-decoration:${textDecoration};`;\n        }\n        return result;\n    }\n    static getPresentationFromMetadata(metadata) {\n        const foreground = this.getForeground(metadata);\n        const fontStyle = this.getFontStyle(metadata);\n        return {\n            foreground: foreground,\n            italic: Boolean(fontStyle & 1 /* FontStyle.Italic */),\n            bold: Boolean(fontStyle & 2 /* FontStyle.Bold */),\n            underline: Boolean(fontStyle & 4 /* FontStyle.Underline */),\n            strikethrough: Boolean(fontStyle & 8 /* FontStyle.Strikethrough */),\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ILanguageService = createDecorator('languageService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t'; }\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t'; }\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\nimport { createBracketOrRegExp } from './richEditBrackets.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            const openingColorized = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening, openingColorized),\n                opening,\n                openingColorized,\n            };\n        });\n        for (const [open, close] of bracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        // Treat colorized brackets as brackets, and mark them as colorized.\n        const colorizedBracketPairs = config.colorizedBracketPairs\n            ? filterValidBrackets(config.colorizedBracketPairs)\n            // If not configured: Take all brackets except `<` ... `>`\n            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.\n            // https://github.com/microsoft/vscode/issues/132476\n            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));\n        for (const [open, close] of colorizedBracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.openingColorized.add(opening.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n    getBracketRegExp(options) {\n        const brackets = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);\n        return createBracketOrRegExp(brackets, options);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    openingBrackets, openingColorizedBrackets) {\n        super(config, bracketText);\n        this.openingBrackets = openingBrackets;\n        this.openingColorizedBrackets = openingColorizedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * If the bracket infos come from different configurations, this method will return false.\n    */\n    closes(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingBrackets.has(other);\n    }\n    closesColorized(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingColorizedBrackets.has(other);\n    }\n    getOpeningBrackets() {\n        return [...this.openingBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            // this happens for the null language, which can be returned by monarch.\n            // Instead of throwing an error, we just return a default config.\n            return new ResolvedLanguageConfiguration(languageId, {});\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return entries?.getResolvedConfiguration() || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return this.characterPair.getAutoCloseBeforeSet(forQuotes);\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n        this.languageIdCodec = actual.languageIdCodec;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getLineLength() {\n        return this._lastCharOffset - this.firstCharOffset;\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n    toIViewLineTokens() {\n        return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nexport function createBracketOrRegExp(pieces, options) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true, options);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem ?? s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/textLength.js';\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new TextLength(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static { this.cache = new Array(129); }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static { this.empty = SmallImmutableSet.create(0, emptyArr); }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)?.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TokenizationTextModelPart_1;\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry, TreeSitterTokenizationRegistry } from '../languages.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { AbstractTokens, AttachedViewHandler } from './tokens.js';\nimport { TreeSitterTokens } from './treeSitterTokens.js';\nimport { ITreeSitterParserService } from '../services/treeSitterParserService.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nlet TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends TextModelPart {\n    constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _treeSitterService) {\n        super();\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._treeSitterService = _treeSitterService;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._tokensDisposables = this._register(new DisposableStore());\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        // We just look at registry changes to determine whether to use tree sitter.\n        // This means that removing a language from the setting will not cause a switch to textmate and will require a reload.\n        // Adding a language to the setting will not need a reload, however.\n        this._register(Event.filter(TreeSitterTokenizationRegistry.onDidChange, (e) => e.changedLanguages.includes(this._languageId))(() => {\n            this.createPreferredTokenProvider();\n        }));\n        this.createPreferredTokenProvider();\n    }\n    createGrammarTokens() {\n        return this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n    }\n    createTreeSitterTokens() {\n        return this._register(new TreeSitterTokens(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));\n    }\n    createTokens(useTreeSitter) {\n        const needsReset = this._tokens !== undefined;\n        this._tokens?.dispose();\n        this._tokens = useTreeSitter ? this.createTreeSitterTokens() : this.createGrammarTokens();\n        this._tokensDisposables.clear();\n        this._tokensDisposables.add(this._tokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n        if (needsReset) {\n            // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n            this._tokens.resetTokenization();\n        }\n    }\n    createPreferredTokenProvider() {\n        if (TreeSitterTokenizationRegistry.get(this._languageId)) {\n            if (!(this._tokens instanceof TreeSitterTokens)) {\n                this.createTokens(true);\n            }\n        }\n        else {\n            if (!(this._tokens instanceof GrammarTokens)) {\n                this.createTokens(false);\n            }\n        }\n    }\n    handleLanguageConfigurationServiceChange(e) {\n        if (e.affects(this._languageId)) {\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this._tokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this._tokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this._tokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n    resetTokenization() {\n        this._tokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this._tokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this._tokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this._tokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._tokens.resetTokenization();\n        this.createPreferredTokenProvider();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n};\nTokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([\n    __param(4, ILanguageService),\n    __param(5, ILanguageConfigurationService),\n    __param(6, ITreeSitterParserService)\n], TokenizationTextModelPart);\nexport { TokenizationTextModelPart };\nclass GrammarTokens extends AbstractTokens {\n    constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {\n        super(languageIdCodec, textModel, getLanguageId);\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        this._tokens.flush();\n        this._debugBackgroundTokens?.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        this._tokenizer?.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        this._debugBackgroundStates?.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        this._defaultBackgroundTokenizer?.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            this._debugBackgroundStates?.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            this._defaultBackgroundTokenizer?.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static { TextModel_1 = this; }\n    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests\n    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;\n    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines\n    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage\n    static { this.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n        bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n    }; }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this.instantiationService = instantiationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n        }));\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new BugIndicatingError('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, IInstantiationService)\n], TextModel);\nexport { TextModel };\nexport function indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        this.position = options?.position ?? model.GlyphMarginLane.Center;\n        this.persistLane = options?.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n        this.sectionHeaderText = options.sectionHeaderText ?? null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n        this.blockPadding = options.blockPadding ?? null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n        this.hideInStringTokens = options.hideInStringTokens ?? false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            this._affectedInjectedTextLines?.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        this._affectsMinimap ||= !!options.minimap?.position;\n        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n        this._affectsLineNumber ||= !!options.lineNumberClassName;\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /** 0-based */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.bracketPairNode = bracketPairNode;\n    }\n    get openingBracketInfo() {\n        return this.bracketPairNode.openingBracket.bracketInfo;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, node.child?.length || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n    }\n    //#region TextModel events\n    handleLanguageConfigurationServiceChange(e) {\n        if (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }\n    }\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        this.bracketPairsTree.value?.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        this.bracketPairsTree.value?.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable?.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    static { this.INSTANCE = new BracketSearchCanceled(); }\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { FixedArray } from './fixedArray.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nexport class TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = this.tokenizationSupport.getInitialState();\n        this.store = new TrackingTokenizationStateStore(lineCount);\n    }\n    getStartState(lineNumber) {\n        return this.store.getStartState(lineNumber, this.initialState);\n    }\n    getFirstInvalidLine() {\n        return this.store.getFirstInvalidLine(this.initialState);\n    }\n}\nexport class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {\n        super(lineCount, tokenizationSupport);\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n    }\n    updateTokensUntilLine(builder, lineNumber) {\n        const languageId = this._textModel.getLanguageId();\n        while (true) {\n            const lineToTokenize = this.getFirstInvalidLine();\n            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n                break;\n            }\n            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n            builder.add(lineToTokenize.lineNumber, r.tokens);\n            this.store.setEndState(lineToTokenize.lineNumber, r.endState);\n        }\n    }\n    /** assumes state is up to date */\n    getTokenTypeIfInsertingCharacter(position, character) {\n        // TODO@hediet: use tokenizeLineWithEdit\n        const lineStartState = this.getStartState(position.lineNumber);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    /** assumes state is up to date */\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        const lineStartState = this.getStartState(lineNumber);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        return (lineNumber < firstInvalidLineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (lineNumber === firstInvalidLineNumber\n            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The result is not cached.\n     */\n    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {\n        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // nothing to do\n            return { heuristicTokens: false };\n        }\n        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // tokenization has reached the viewport start...\n            this.updateTokensUntilLine(builder, endLineNumber);\n            return { heuristicTokens: false };\n        }\n        let state = this.guessStartState(startLineNumber);\n        const languageId = this._textModel.getLanguageId();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            state = r.endState;\n        }\n        return { heuristicTokens: true };\n    }\n    guessStartState(lineNumber) {\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n        const likelyRelevantLines = [];\n        let initialState = null;\n        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            // Ignore lines full of whitespace\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                likelyRelevantLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n                initialState = this.getStartState(i);\n                if (initialState) {\n                    break;\n                }\n            }\n        }\n        if (!initialState) {\n            initialState = this.tokenizationSupport.getInitialState();\n        }\n        likelyRelevantLines.reverse();\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (const line of likelyRelevantLines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n            state = r.endState;\n        }\n        return state;\n    }\n}\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore {\n    constructor(lineCount) {\n        this.lineCount = lineCount;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n    }\n    getEndState(lineNumber) {\n        return this._tokenizationStateStore.getEndState(lineNumber);\n    }\n    /**\n     * @returns if the end state has changed.\n     */\n    setEndState(lineNumber, state) {\n        if (!state) {\n            throw new BugIndicatingError('Cannot set null/undefined state');\n        }\n        this._invalidEndStatesLineNumbers.delete(lineNumber);\n        const r = this._tokenizationStateStore.setEndState(lineNumber, state);\n        if (r && lineNumber < this.lineCount) {\n            // because the state changed, we cannot trust the next state anymore and have to invalidate it.\n            this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n        }\n        return r;\n    }\n    acceptChange(range, newLineCount) {\n        this.lineCount += newLineCount - range.length;\n        this._tokenizationStateStore.acceptChange(range, newLineCount);\n        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n    }\n    acceptChanges(changes) {\n        for (const c of changes) {\n            const [eolCount] = countEOL(c.text);\n            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n        }\n    }\n    invalidateEndStateRange(range) {\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n    }\n    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }\n    getFirstInvalidEndStateLineNumberOrMax() {\n        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n    }\n    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }\n    getStartState(lineNumber, initialState) {\n        if (lineNumber === 1) {\n            return initialState;\n        }\n        return this.getEndState(lineNumber - 1);\n    }\n    getFirstInvalidLine(initialState) {\n        const lineNumber = this.getFirstInvalidEndStateLineNumber();\n        if (lineNumber === null) {\n            return null;\n        }\n        const startState = this.getStartState(lineNumber, initialState);\n        if (!startState) {\n            throw new BugIndicatingError('Start state must be defined');\n        }\n        return { lineNumber, startState };\n    }\n}\nexport class TokenizationStateStore {\n    constructor() {\n        this._lineEndStates = new FixedArray(null);\n    }\n    getEndState(lineNumber) {\n        return this._lineEndStates.get(lineNumber);\n    }\n    setEndState(lineNumber, state) {\n        const oldState = this._lineEndStates.get(lineNumber);\n        if (oldState && oldState.equals(state)) {\n            return false;\n        }\n        this._lineEndStates.set(lineNumber, state);\n        return true;\n    }\n    acceptChange(range, newLineCount) {\n        let length = range.length;\n        if (newLineCount > 0 && length > 0) {\n            // Keep the last state, even though it is unrelated.\n            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n            length--;\n            newLineCount--;\n        }\n        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n    }\n}\nexport class RangePriorityQueueImpl {\n    constructor() {\n        this._ranges = [];\n    }\n    get min() {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return this._ranges[0].start;\n    }\n    delete(value) {\n        const idx = this._ranges.findIndex(r => r.contains(value));\n        if (idx !== -1) {\n            const range = this._ranges[idx];\n            if (range.start === value) {\n                if (range.endExclusive === value + 1) {\n                    this._ranges.splice(idx, 1);\n                }\n                else {\n                    this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n                }\n            }\n            else {\n                if (range.endExclusive === value + 1) {\n                    this._ranges[idx] = new OffsetRange(range.start, value);\n                }\n                else {\n                    this._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n                }\n            }\n        }\n    }\n    addRange(range) {\n        OffsetRange.addRange(range, this._ranges);\n    }\n    addRangeAndResize(range, newLength) {\n        let idxFirstMightBeIntersecting = 0;\n        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n            idxFirstMightBeIntersecting++;\n        }\n        let idxFirstIsAfter = idxFirstMightBeIntersecting;\n        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n            idxFirstIsAfter++;\n        }\n        const delta = newLength - range.length;\n        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n            this._ranges[i] = this._ranges[i].delta(delta);\n        }\n        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n            const newRange = new OffsetRange(range.start, range.start + newLength);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n            }\n        }\n        else {\n            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n            const newRange = new OffsetRange(start, endEx + delta);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n            }\n            else {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n            }\n        }\n    }\n    toString() {\n        return this._ranges.map(r => r.toString()).join(' + ');\n    }\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\nexport class DefaultBackgroundTokenizer {\n    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {\n        this._tokenizerWithStateStore = _tokenizerWithStateStore;\n        this._backgroundTokenStore = _backgroundTokenStore;\n        this._isDisposed = false;\n        this._isScheduled = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    handleChanges() {\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenGlobalIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._backgroundTokenStore.setTokens(builder.finalize());\n        this.checkFinished();\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizerWithStateStore) {\n            return false;\n        }\n        return !this._tokenizerWithStateStore.store.allStatesValid();\n    }\n    _tokenizeOneInvalidLine(builder) {\n        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n        if (!firstInvalidLine) {\n            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n        }\n        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n        return firstInvalidLine.lineNumber;\n    }\n    checkFinished() {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this._tokenizerWithStateStore.store.allStatesValid()) {\n            this._backgroundTokenStore.backgroundTokenizationFinished();\n        }\n    }\n    requestTokens(startLineNumber, endLineNumberExclusive) {\n        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LineRange } from '../core/lineRange.js';\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\nexport class AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\nexport class AbstractTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeSitterTokenizationRegistry } from '../languages.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { AbstractTokens } from './tokens.js';\nexport class TreeSitterTokens extends AbstractTokens {\n    constructor(_treeSitterService, languageIdCodec, textModel, languageId) {\n        super(languageIdCodec, textModel, languageId);\n        this._treeSitterService = _treeSitterService;\n        this._tokenizationSupport = null;\n        this._initialize();\n    }\n    _initialize() {\n        const newLanguage = this.getLanguageId();\n        if (!this._tokenizationSupport || this._lastLanguageId !== newLanguage) {\n            this._lastLanguageId = newLanguage;\n            this._tokenizationSupport = TreeSitterTokenizationRegistry.get(newLanguage);\n        }\n    }\n    getLineTokens(lineNumber) {\n        const content = this._textModel.getLineContent(lineNumber);\n        if (this._tokenizationSupport) {\n            const rawTokens = this._tokenizationSupport.tokenizeEncoded(lineNumber, this._textModel);\n            if (rawTokens) {\n                return new LineTokens(rawTokens, content, this._languageIdCodec);\n            }\n        }\n        return LineTokens.createEmpty(content, this._languageIdCodec);\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        this._initialize();\n    }\n    handleDidChangeAttached() {\n        // TODO @alexr00 implement for background tokenization\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n    }\n    forceTokenization(lineNumber) {\n        // TODO @alexr00 implement\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    isCheapToTokenize(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        // TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value\n        return 0 /* StandardTokenType.Other */;\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        // TODO @alexr00 understand what this is for and implement\n        return null;\n    }\n    get hasTokens() {\n        // TODO @alexr00 once we have a token store, implement properly\n        const hasTree = this._treeSitterService.getParseResult(this._textModel) !== undefined;\n        return hasTree;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    get hasTokens() {\n        return this._lineTokens.length > 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n    //#endregion\n    setMultilineTokens(tokens, textModel) {\n        if (tokens.length === 0) {\n            return { changes: [] };\n        }\n        const ranges = [];\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const element = tokens[i];\n            let minChangedLineNumber = 0;\n            let maxChangedLineNumber = 0;\n            let hasChange = false;\n            for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                if (hasChange) {\n                    this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                    maxChangedLineNumber = lineNumber;\n                }\n                else {\n                    const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                    if (lineHasChange) {\n                        hasChange = true;\n                        minChangedLineNumber = lineNumber;\n                        maxChangedLineNumber = lineNumber;\n                    }\n                }\n            }\n            if (hasChange) {\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n            }\n        }\n        return { changes: ranges };\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        if (aTokens.getLineContent().length === 0) {\n            // Don't do anything for empty lines\n            return aTokens;\n        }\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ModelService_1;\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { TextModel } from '../model/textModel.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { ITextResourcePropertiesService } from './textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { StringSHA1 } from '../../../base/common/hash.js';\nimport { isEditStackElement } from '../model/editStack.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { equals } from '../../../base/common/objects.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nfunction MODEL_ID(resource) {\n    return resource.toString();\n}\nclass ModelData {\n    constructor(model, onWillDispose, onDidChangeLanguage) {\n        this.model = model;\n        this._modelEventListeners = new DisposableStore();\n        this.model = model;\n        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));\n        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));\n    }\n    dispose() {\n        this._modelEventListeners.dispose();\n    }\n}\nconst DEFAULT_EOL = (platform.isLinux || platform.isMacintosh) ? 1 /* DefaultEndOfLine.LF */ : 2 /* DefaultEndOfLine.CRLF */;\nclass DisposedModelInfo {\n    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {\n        this.uri = uri;\n        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;\n        this.time = time;\n        this.sharesUndoRedoStack = sharesUndoRedoStack;\n        this.heapSize = heapSize;\n        this.sha1 = sha1;\n        this.versionId = versionId;\n        this.alternativeVersionId = alternativeVersionId;\n    }\n}\nlet ModelService = class ModelService extends Disposable {\n    static { ModelService_1 = this; }\n    static { this.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024; }\n    constructor(_configurationService, _resourcePropertiesService, _undoRedoService, _instantiationService) {\n        super();\n        this._configurationService = _configurationService;\n        this._resourcePropertiesService = _resourcePropertiesService;\n        this._undoRedoService = _undoRedoService;\n        this._instantiationService = _instantiationService;\n        this._onModelAdded = this._register(new Emitter());\n        this.onModelAdded = this._onModelAdded.event;\n        this._onModelRemoved = this._register(new Emitter());\n        this.onModelRemoved = this._onModelRemoved.event;\n        this._onModelModeChanged = this._register(new Emitter());\n        this.onModelLanguageChanged = this._onModelModeChanged.event;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        this._models = {};\n        this._disposedModels = new Map();\n        this._disposedModelsHeapSize = 0;\n        this._register(this._configurationService.onDidChangeConfiguration(e => this._updateModelOptions(e)));\n        this._updateModelOptions(undefined);\n    }\n    static _readModelOptions(config, isForSimpleWidget) {\n        let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;\n        if (config.editor && typeof config.editor.tabSize !== 'undefined') {\n            const parsedTabSize = parseInt(config.editor.tabSize, 10);\n            if (!isNaN(parsedTabSize)) {\n                tabSize = parsedTabSize;\n            }\n            if (tabSize < 1) {\n                tabSize = 1;\n            }\n        }\n        let indentSize = 'tabSize';\n        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {\n            const parsedIndentSize = parseInt(config.editor.indentSize, 10);\n            if (!isNaN(parsedIndentSize)) {\n                indentSize = Math.max(parsedIndentSize, 1);\n            }\n        }\n        let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;\n        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {\n            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));\n        }\n        let newDefaultEOL = DEFAULT_EOL;\n        const eol = config.eol;\n        if (eol === '\\r\\n') {\n            newDefaultEOL = 2 /* DefaultEndOfLine.CRLF */;\n        }\n        else if (eol === '\\n') {\n            newDefaultEOL = 1 /* DefaultEndOfLine.LF */;\n        }\n        let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;\n        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {\n            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));\n        }\n        let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;\n        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {\n            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));\n        }\n        let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;\n        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {\n            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));\n        }\n        let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;\n        if (config.editor?.bracketPairColorization && typeof config.editor.bracketPairColorization === 'object') {\n            bracketPairColorizationOptions = {\n                enabled: !!config.editor.bracketPairColorization.enabled,\n                independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType\n            };\n        }\n        return {\n            isForSimpleWidget: isForSimpleWidget,\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            detectIndentation: detectIndentation,\n            defaultEOL: newDefaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            largeFileOptimizations: largeFileOptimizations,\n            bracketPairColorizationOptions\n        };\n    }\n    _getEOL(resource, language) {\n        if (resource) {\n            return this._resourcePropertiesService.getEOL(resource, language);\n        }\n        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return platform.OS === 3 /* platform.OperatingSystem.Linux */ || platform.OS === 2 /* platform.OperatingSystem.Macintosh */ ? '\\n' : '\\r\\n';\n    }\n    _shouldRestoreUndoStack() {\n        const result = this._configurationService.getValue('files.restoreUndoStack');\n        if (typeof result === 'boolean') {\n            return result;\n        }\n        return true;\n    }\n    getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget) {\n        const language = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];\n        if (!creationOptions) {\n            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });\n            const eol = this._getEOL(resource, language);\n            creationOptions = ModelService_1._readModelOptions({ editor, eol }, isForSimpleWidget);\n            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;\n        }\n        return creationOptions;\n    }\n    _updateModelOptions(e) {\n        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        // Update options on all models\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            const modelData = this._models[modelId];\n            const language = modelData.model.getLanguageId();\n            const uri = modelData.model.uri;\n            if (e && !e.affectsConfiguration('editor', { overrideIdentifier: language, resource: uri }) && !e.affectsConfiguration('files.eol', { overrideIdentifier: language, resource: uri })) {\n                continue; // perf: skip if this model is not affected by configuration change\n            }\n            const oldOptions = oldOptionsByLanguageAndResource[language + uri];\n            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);\n            ModelService_1._setModelOptionsForModel(modelData.model, newOptions, oldOptions);\n        }\n    }\n    static _setModelOptionsForModel(model, newOptions, currentOptions) {\n        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {\n            model.setEOL(newOptions.defaultEOL === 1 /* DefaultEndOfLine.LF */ ? 0 /* EndOfLineSequence.LF */ : 1 /* EndOfLineSequence.CRLF */);\n        }\n        if (currentOptions\n            && (currentOptions.detectIndentation === newOptions.detectIndentation)\n            && (currentOptions.insertSpaces === newOptions.insertSpaces)\n            && (currentOptions.tabSize === newOptions.tabSize)\n            && (currentOptions.indentSize === newOptions.indentSize)\n            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)\n            && equals(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {\n            // Same indent opts, no need to touch the model\n            return;\n        }\n        if (newOptions.detectIndentation) {\n            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);\n            model.updateOptions({\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n        else {\n            model.updateOptions({\n                insertSpaces: newOptions.insertSpaces,\n                tabSize: newOptions.tabSize,\n                indentSize: newOptions.indentSize,\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n    }\n    // --- begin IModelService\n    _insertDisposedModel(disposedModelData) {\n        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);\n        this._disposedModelsHeapSize += disposedModelData.heapSize;\n    }\n    _removeDisposedModel(resource) {\n        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));\n        if (disposedModelData) {\n            this._disposedModelsHeapSize -= disposedModelData.heapSize;\n        }\n        this._disposedModels.delete(MODEL_ID(resource));\n        return disposedModelData;\n    }\n    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {\n        if (this._disposedModelsHeapSize > maxModelsHeapSize) {\n            // we must remove some old undo stack elements to free up some memory\n            const disposedModels = [];\n            this._disposedModels.forEach(entry => {\n                if (!entry.sharesUndoRedoStack) {\n                    disposedModels.push(entry);\n                }\n            });\n            disposedModels.sort((a, b) => a.time - b.time);\n            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {\n                const disposedModel = disposedModels.shift();\n                this._removeDisposedModel(disposedModel.uri);\n                if (disposedModel.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);\n                }\n            }\n        }\n    }\n    _createModelData(value, languageIdOrSelection, resource, isForSimpleWidget) {\n        // create & save the model\n        const options = this.getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget);\n        const model = this._instantiationService.createInstance(TextModel, value, languageIdOrSelection, options, resource);\n        if (resource && this._disposedModels.has(MODEL_ID(resource))) {\n            const disposedModelData = this._removeDisposedModel(resource);\n            const elements = this._undoRedoService.getElements(resource);\n            const sha1Computer = this._getSHA1Computer();\n            const sha1IsEqual = (sha1Computer.canComputeSHA1(model)\n                ? sha1Computer.computeSHA1(model) === disposedModelData.sha1\n                : false);\n            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                this._undoRedoService.setElementsValidFlag(resource, true, (element) => (isEditStackElement(element) && element.matchesResource(resource)));\n                if (sha1IsEqual) {\n                    model._overwriteVersionId(disposedModelData.versionId);\n                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);\n                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n            else {\n                if (disposedModelData.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n        }\n        const modelId = MODEL_ID(model.uri);\n        if (this._models[modelId]) {\n            // There already exists a model with this id => this is a programmer error\n            throw new Error('ModelService: Cannot add model because it already exists!');\n        }\n        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));\n        this._models[modelId] = modelData;\n        return modelData;\n    }\n    createModel(value, languageSelection, resource, isForSimpleWidget = false) {\n        let modelData;\n        if (languageSelection) {\n            modelData = this._createModelData(value, languageSelection, resource, isForSimpleWidget);\n        }\n        else {\n            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);\n        }\n        this._onModelAdded.fire(modelData.model);\n        return modelData.model;\n    }\n    getModels() {\n        const ret = [];\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            ret.push(this._models[modelId].model);\n        }\n        return ret;\n    }\n    getModel(resource) {\n        const modelId = MODEL_ID(resource);\n        const modelData = this._models[modelId];\n        if (!modelData) {\n            return null;\n        }\n        return modelData.model;\n    }\n    // --- end IModelService\n    _schemaShouldMaintainUndoRedoElements(resource) {\n        return (resource.scheme === Schemas.file\n            || resource.scheme === Schemas.vscodeRemote\n            || resource.scheme === Schemas.vscodeUserData\n            || resource.scheme === Schemas.vscodeNotebookCell\n            || resource.scheme === 'fake-fs' // for tests\n        );\n    }\n    _onWillDispose(model) {\n        const modelId = MODEL_ID(model.uri);\n        const modelData = this._models[modelId];\n        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());\n        let maintainUndoRedoStack = false;\n        let heapSize = 0;\n        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri))) {\n            const elements = this._undoRedoService.getElements(model.uri);\n            if (elements.past.length > 0 || elements.future.length > 0) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n            }\n        }\n        const maxMemory = ModelService_1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;\n        const sha1Computer = this._getSHA1Computer();\n        if (!maintainUndoRedoStack) {\n            if (!sharesUndoRedoStack) {\n                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n                if (initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n                }\n            }\n        }\n        else if (!sharesUndoRedoStack && (heapSize > maxMemory || !sha1Computer.canComputeSHA1(model))) {\n            // the undo stack for this file would never fit in the configured memory or the file is very large, so don't bother with it.\n            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n            if (initialUndoRedoSnapshot !== null) {\n                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n            }\n        }\n        else {\n            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);\n            // We only invalidate the elements, but they remain in the undo-redo service.\n            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => (isEditStackElement(element) && element.matchesResource(model.uri)));\n            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, sha1Computer.computeSHA1(model), model.getVersionId(), model.getAlternativeVersionId()));\n        }\n        delete this._models[modelId];\n        modelData.dispose();\n        // clean up cache\n        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];\n        this._onModelRemoved.fire(model);\n    }\n    _onDidChangeLanguage(model, e) {\n        const oldLanguageId = e.oldLanguage;\n        const newLanguageId = model.getLanguageId();\n        const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);\n        const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);\n        ModelService_1._setModelOptionsForModel(model, newOptions, oldOptions);\n        this._onModelModeChanged.fire({ model, oldLanguageId: oldLanguageId });\n    }\n    _getSHA1Computer() {\n        return new DefaultModelSHA1Computer();\n    }\n};\nModelService = ModelService_1 = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ITextResourcePropertiesService),\n    __param(2, IUndoRedoService),\n    __param(3, IInstantiationService)\n], ModelService);\nexport { ModelService };\nexport class DefaultModelSHA1Computer {\n    static { this.MAX_MODEL_SIZE = 10 * 1024 * 1024; } // takes 200ms to compute a sha1 on a 10MB model on a new machine\n    canComputeSHA1(model) {\n        return (model.getValueLength() <= DefaultModelSHA1Computer.MAX_MODEL_SIZE);\n    }\n    computeSHA1(model) {\n        // compute the sha1\n        const shaComputer = new StringSHA1();\n        const snapshot = model.createSnapshot();\n        let text;\n        while ((text = snapshot.read())) {\n            shaComputer.update(text);\n        }\n        return shaComputer.digest();\n    }\n}\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITextResourceConfigurationService = createDecorator('textResourceConfigurationService');\nexport const ITextResourcePropertiesService = createDecorator('textResourcePropertiesService');\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITreeSitterParserService = createDecorator('treeSitterParserService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* RawContentChangedType.Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* RawContentChangedType.LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* RawContentChangedType.LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* RawContentChangedType.LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* RawContentChangedType.EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        const isEolChange = a.isEolChange && b.isEolChange; // both must be true to not confuse listeners who skip such edits\n        return {\n            changes: changes,\n            eol: eol,\n            isEolChange: isEolChange,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush,\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, column, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine, \n    /**\n     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.\n    */\n    forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {\n        this.visibleColumn = visibleColumn;\n        this.column = column;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;\n        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;\n        if ((visibleColumn !== -1) === (column !== -1)) {\n            throw new Error();\n        }\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static { this.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0; }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    static createFromTextAndMetadata(data, decoder) {\n        let offset = 0;\n        let fullText = '';\n        const tokens = new Array();\n        for (const { text, metadata } of data) {\n            tokens.push(offset + text.length, metadata);\n            offset += text.length;\n            fullText += text;\n        }\n        return new LineTokens(new Uint32Array(tokens), fullText, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this.languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this.languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this.languageIdCodec);\n    }\n    getTokenText(tokenIndex) {\n        const startOffset = this.getStartOffset(tokenIndex);\n        const endOffset = this.getEndOffset(tokenIndex);\n        const text = this._text.substring(startOffset, endOffset);\n        return text;\n    }\n    forEach(callback) {\n        const tokenCount = this.getCount();\n        for (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this.languageIdCodec = source.languageIdCodec;\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n    getTokenText(tokenIndex) {\n        const adjustedTokenIndex = this._firstTokenIndex + tokenIndex;\n        const tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);\n        const tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);\n        let text = this._source.getTokenText(adjustedTokenIndex);\n        if (tokenStartOffset < this._startOffset) {\n            text = text.substring(this._startOffset - tokenStartOffset);\n        }\n        if (tokenEndOffset > this._endOffset) {\n            text = text.substring(0, text.length - (tokenEndOffset - this._endOffset));\n        }\n        return text;\n    }\n    forEach(callback) {\n        for (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nexport function getStandardTokenTypeAtPosition(model, position) {\n    const lineNumber = position.lineNumber;\n    if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n        return undefined;\n    }\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n    return tokenType;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class SyncDescriptor {\n    constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {\n        this.ctor = ctor;\n        this.staticArguments = staticArguments;\n        this.supportsDelayedInstantiation = supportsDelayedInstantiation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SyncDescriptor } from './descriptors.js';\nconst _registry = [];\nexport function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {\n    if (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n        ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], Boolean(supportsDelayedInstantiation));\n    }\n    _registry.push([id, ctorOrDescriptor]);\n}\nexport function getSingletonServiceDescriptors() {\n    return _registry;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IUndoRedoService = createDecorator('undoRedoService');\nexport class ResourceEditStackSnapshot {\n    constructor(resource, elements) {\n        this.resource = resource;\n        this.elements = elements;\n    }\n}\nexport class UndoRedoGroup {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoGroup._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoGroup(); }\n}\nexport class UndoRedoSource {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoSource._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoSource(); }\n}\n"],"names":["Buffer","Uint8Array","TextDecoder","Math","t","d","Uint16Array","r","String","n","e","i","Array","Map","a","s","RegExp","Set","Object","arguments","Reflect","Uint32Array","Error","Number","l","u","c","h","Date","o","isNaN","console","parseInt"],"mappings":"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"}